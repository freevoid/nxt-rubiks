const char PEDESTAL_PORT = OUT_A;
const char HAND_PORT = OUT_B;
const char CAMERA_PORT = OUT_C;

bool HELP_VERTICAL_TURN = false;
int STRONG_HORIZONTAL_TURN_POWER = 50;
int NORMAL_HORIZONTAL_TURN_POWER = 30;

int pedestal_angle;
int pedestal_angle_error = 0;

sub ConfigureHorizontalTurnPower(int normal, int strong) {
    STRONG_HORIZONTAL_TURN_POWER = strong;
    NORMAL_HORIZONTAL_TURN_POWER = normal;
}

sub VerticalTurn() {
    Off(PEDESTAL_PORT);
    RotateMotor(HAND_PORT, 88, 65);
    Wait(400);
    if (HELP_VERTICAL_TURN) {
        RotateMotor(HAND_PORT, 50, -45);
        RotateMotor(HAND_PORT, 88, 15);
        Wait(100);
        RotateMotor(HAND_PORT, 50, -35);
    } else {
        RotateMotor(HAND_PORT, 50, -65);
    }
}

sub HorizontalTurn(int count, bool strong) {
    int strength = strong ? STRONG_HORIZONTAL_TURN_POWER : NORMAL_HORIZONTAL_TURN_POWER;
    int angle;
    if (count == 1) {
        angle = 90;
    }
    if (count == 2) {
        angle = 180;
    }
    if (count == 3) {
        angle = -90;
    }
    //angle -= pedestal_angle_error;
    //int predicted_angle = pedestal_angle + angle;
    RotateMotor(PEDESTAL_PORT, strength, angle);
    //pedestal_angle_error = MotorTachoCount(PEDESTAL_PORT) - predicted_angle;
}

sub Move(int count, int power, int degree) {
    RotateMotor(HAND_PORT, power, degree);
    Off(HAND_PORT);
    HorizontalTurn(count, true); 
    RotateMotor(HAND_PORT, power, -degree);
}

/*
task main() {
    pedestal_angle = MotorTachoCount(PEDESTAL_PORT);
    RotateMotor(PEDESTAL_PORT, 20, -pedestal_angle);
    HorizontalTurn(1, false);
    VerticalTurn();
    Move(2);
    VerticalTurn();
    HorizontalTurn(3, false);
}
*/

